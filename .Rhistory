install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
library("devtools")
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat"))
q()
install.packages(c("devtools", "roxygen2", "testthat"))
q()
library("devtools")
q()
library("devtools")
devtools::dev_sitrep()
.libpaths()
.libPaths()
usethis::create_package()
.ls
usethis::create_package('microscope')
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
microscope::hello_function("Robin")
devtools::check()
library(license)
usethis::use_mit_license()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
library(data.table)
animals <- read.csv("../test.csv")
animals
class(animals)
row.names(animals)
help(data.frame)
help("data.frame")
?data.frame
conda install coreutils
help("data.frame")
help("data.frame")
#Rearrange slightly so suitable for inserting into SQL- e.g make sample a column(rather than rownames) and change "pH" colname to "ph" as standard postgres field names without double quotes have to be lower case
#https://deeplearning.lipingyang.org/2017/01/07/postgresql-column-names-of-a-table-are-case-sensitive/
Env_for_SQL=data.frame(sample=row.names(Env_for_SQL),Env_for_SQL[,1:2],ph=Env_for_SQL[,3])
R
1+1
sample <- c('Sample 1', 'Sample 2', 'Sample 3')
pH <- c(6.2, 7.1, 4.2)
OM <- c(7.24.4 30.3)
OM <- c(7.2, 4.4, 30.3)
Habitat <- c('Cropland', 'Cropland', 'Grassland')
temp <- c(8.6, 9.1, 8.5)
env <- data.frame(sample, pH, OM, Habitat, temp)
env
env$pH
row.names(env)
env[,]
env[,1:2]
df <-data.frame(sample=row.names(env), env[,4:5], ph=[,2])
data.frame(sample=row.names(env)
)
data.frame(sample=row.names(env), env[,4:5],)
data.frame(sample=row.names(env), env[,4:5])
data.frame(sample=row.names(env), env[,4:5], ph=end[,2])
data.frame(sample=row.names(env), env[,4:5], ph=env[,2])
base::tolower(JAMA)
base::tolower("JAMA")
base::tolower(c("JAMA", "hhHHH"))
library('data.table')
names(env)
names(env) <- c(1, 2, 3, 4, 5)
env
names(env) <- c('sample', 'pH', 'OM', 'Habitat', 'temp')
env
env$thth = row.names(env)
env
install.packages('data.table')
library('data.table')
?setcolorder
env
setcolorder(env, 'thth', before=1)
env
setcolorder(env, 'thth', after=7)
setcolorder(env, 'thth', after=2)
setcolorder(env, 'thth', after=-1)
setcolorder(env, 'thth', after=6)
env
?setcolorder
setcolorder(env, 'new', value=row.names(env), before=1)
?setcolorder
set(env, 'new', value=row.names(env), before=1)
set(env, 'new', value=row.names(env))
?setcolorder
set(env, j='new', value=row.names(env))
env[,test, row.names(env)]
env[,test := row.names(env)]
dt<- data.table(env)
dt

dt
one <- c(1,2,3,4,5,6,7,8,9,10)
two <- c(1,2,3,4,5,6,7,8,9,10)
three <- c(1,2,3,4,5,6,7,8,9,10)
dft <- data.table(one, two, three
)

rowsum(dft)
rowSums(dft)
rowSums(dft)>5
rowSums(dft)>15
dft[,rowSums(dft)>15]
dft[rowSums(dft)>15]
dft
subset(dft, sum)
subset(dft, rowSums(dft)>15)
subset(dft, rowSums(dft)>11)
subset(dft, rowSums(dft)>1)
subset(dft, rowSums(dft)>15)
dft
dft
dft != 0
(dft != 0)*1
dft[10,1]
dft[10,1] = 0
dft
(dft != 0)*1
(dft != 0)
logical(2)
logical(dft)
as.logical(dft)
dft[, lapply(.SD, as.logical)]
dft[, lapply(.SD, as.numeric(as.logical)]
dft[, lapply(.SD, as.numeric(as.logical))
dft[, lapply(.SD, as.numeric(as.logical))]
dft[, lapply(.SD, as.numeric(as.logical))]
dft[, lapply(.SD, as.logical)]
dft[, lapply(.SD, as.logical)][, lapply(.SD, as.numeric)]
dft1 = dft
dft1
set(dft1, , value = as.logical)
set(dft1, j= , value = as.logical)
dft[, := lapply(.SD, as.logical)][, lapply(.SD, as.numeric)]
dft[,(one) := lapply(.SD, as.logical), .SDcols = 'one']
dft[,('one') := lapply(.SD, as.logical), .SDcols = 'one']
dft
cols <- names(dft)
cols
dft[,(cols) := lapply(.SD, as.logical), .SDcols = cols]
dft
dft[,(cols) := lapply(.SD, as.numeric(as.logical)), .SDcols = cols]
dft[,(cols) := lapply(.SD, as.numeric.as.logical), .SDcols = cols]
binary <- function(x){
return as.numeric(as.logical(x))
binary <- function(x){ x}
binary(2)
binary <- function(x){ return x}
binary <- function(x){ returnValue(x)}
binary(2)
binary <- function(x){ returnValue(as.logical(x))}
binary(2)
binary <- function(x){ returnValue(as.numeric(as.logical(x)))}
binary(2)
binary(0)
binary(1)
dft[,(cols) := lapply(.SD, binary), .SDcols = cols]
dft
cols <- names(dft)
dft
colSums(dft)
which(colSums(dft))
?which
q()
